{"pageProps":{"state":{"globalHeaders":{"https://napari-hub.org":{"level":1,"children":[],"href":"https://napari-hub.org","text":"napari hub"},"https://github.com/napari/napari":{"level":1,"children":[],"href":"https://github.com/napari/napari","text":"napari source code"},"../../developers/index.html":{"level":1,"children":["../../developers/benchmarks.html","../../developers/contributing.html","../../developers/core_dev_guide.html","../../developers/profiling.html","../../developers/release.html","../../developers/testing.html","../../developers/docs.html"],"href":"../../developers/index.html","text":"Developer resources"},"../../developers/docs.html":{"level":2,"children":[],"href":"../../developers/docs.html","text":"Organization of Documentation for napari"},"../../developers/testing.html":{"level":2,"children":[],"href":"../../developers/testing.html","text":"Testing"},"../../developers/release.html":{"level":2,"children":[],"href":"../../developers/release.html","text":"Release Guide"},"../../developers/profiling.html":{"level":2,"children":[],"href":"../../developers/profiling.html","text":"Profiling"},"../../developers/core_dev_guide.html":{"level":2,"children":[],"href":"../../developers/core_dev_guide.html","text":"Core Developer Guide"},"../../developers/contributing.html":{"level":2,"children":[],"href":"../../developers/contributing.html","text":"Contributing Guide"},"../../developers/benchmarks.html":{"level":2,"children":[],"href":"../../developers/benchmarks.html","text":"Benchmarks"},"../../guides/stable/index.html":{"level":1,"children":["../../guides/stable/event_loop.html","../../guides/stable/threading.html","../../guides/stable/perfmon.html","../../guides/stable/rendering.html","../../guides/stable/docker.html","../../guides/stable/performance.html","../../guides/stable/magicgui.html","../../guides/stable/translations.html","../../guides/stable/rendering-explanation.html","../../guides/stable/connecting_events.html","../../guides/stable/connecting_events.html#long-running-blocking-functions","../../guides/stable/3D_interactivity.html"],"href":"../../guides/stable/index.html","text":"Developer guides"},"../../guides/stable/3D_interactivity.html":{"level":2,"children":[],"href":"../../guides/stable/3D_interactivity.html","text":"3D interactivity"},"../../guides/stable/connecting_events.html#long-running-blocking-functions":{"level":2,"children":[],"href":"../../guides/stable/connecting_events.html#long-running-blocking-functions","text":"Long-running, blocking functions"},"../../guides/stable/connecting_events.html":{"level":2,"children":[],"href":"../../guides/stable/connecting_events.html","text":"Hooking up your own events"},"../../guides/stable/rendering-explanation.html":{"level":2,"children":[],"href":"../../guides/stable/rendering-explanation.html","text":"Rendering in napari"},"../../guides/stable/translations.html":{"level":2,"children":[],"href":"../../guides/stable/translations.html","text":"Translations"},"../../guides/stable/magicgui.html":{"level":2,"children":[],"href":"../../guides/stable/magicgui.html","text":"Using magicgui in napari"},"../../guides/stable/performance.html":{"level":2,"children":[],"href":"../../guides/stable/performance.html","text":"Napari Performance"},"../../guides/stable/docker.html":{"level":2,"children":[],"href":"../../guides/stable/docker.html","text":"Napari in Docker (WIP)"},"../../guides/stable/rendering.html":{"level":2,"children":[],"href":"../../guides/stable/rendering.html","text":"Asynchronous Rendering"},"../../guides/stable/perfmon.html":{"level":2,"children":[],"href":"../../guides/stable/perfmon.html","text":"Performance Monitoring"},"../../guides/stable/threading.html":{"level":2,"children":[],"href":"../../guides/stable/threading.html","text":"Multithreading in napari"},"../../guides/stable/event_loop.html":{"level":2,"children":[],"href":"../../guides/stable/event_loop.html","text":"An Introduction to the Event Loop in napari"},"../../roadmaps/index.html":{"level":1,"children":["../../roadmaps/0_4.html","../../roadmaps/0_3_retrospective.html","../../roadmaps/0_3.html"],"href":"../../roadmaps/index.html","text":"Roadmaps"},"../../roadmaps/0_3.html":{"level":2,"children":[],"href":"../../roadmaps/0_3.html","text":"Roadmap 0.3"},"../../roadmaps/0_3_retrospective.html":{"level":2,"children":[],"href":"../../roadmaps/0_3_retrospective.html","text":"Roadmap 0.3 Retrospective"},"../../roadmaps/0_4.html":{"level":2,"children":[],"href":"../../roadmaps/0_4.html","text":"Roadmap 0.4"},"../../api/stable/index.html":{"level":1,"children":["../../api/stable/napari.layers.html","../../api/stable/napari.view_layers.html","../../api/stable/napari.types.html","../../api/stable/napari.utils.html","../../api/stable/napari.plugins.html","../../api/stable/napari.components.html","../../api/stable/napari.qt.threading.html","../../api/stable/napari.utils.perf.html","../../api/stable/napari.html"],"href":"../../api/stable/index.html","text":"API reference"},"../../api/stable/napari.html":{"level":2,"children":["../../api/stable/napari.Viewer.html"],"href":"../../api/stable/napari.html","text":"napari"},"../../api/stable/napari.Viewer.html":{"level":3,"children":[],"href":"../../api/stable/napari.Viewer.html","text":"napari.Viewer"},"../../api/stable/napari.utils.perf.html":{"level":2,"children":["../../api/stable/napari.utils.perf.PerfEvent.html"],"href":"../../api/stable/napari.utils.perf.html","text":"napari.utils.perf"},"../../api/stable/napari.utils.perf.PerfEvent.html":{"level":3,"children":[],"href":"../../api/stable/napari.utils.perf.PerfEvent.html","text":"napari.utils.perf.PerfEvent"},"../../api/stable/napari.qt.threading.html":{"level":2,"children":["../../api/stable/napari.qt.threading.FunctionWorker.html","../../api/stable/napari.qt.threading.GeneratorWorker.html","../../api/stable/napari.qt.threading.GeneratorWorkerSignals.html","../../api/stable/napari.qt.threading.WorkerBase.html","../../api/stable/napari.qt.threading.WorkerBaseSignals.html"],"href":"../../api/stable/napari.qt.threading.html","text":"napari.qt.threading"},"../../api/stable/napari.qt.threading.WorkerBaseSignals.html":{"level":3,"children":[],"href":"../../api/stable/napari.qt.threading.WorkerBaseSignals.html","text":"napari.qt.threading.WorkerBaseSignals"},"../../api/stable/napari.qt.threading.WorkerBase.html":{"level":3,"children":[],"href":"../../api/stable/napari.qt.threading.WorkerBase.html","text":"napari.qt.threading.WorkerBase"},"../../api/stable/napari.qt.threading.GeneratorWorkerSignals.html":{"level":3,"children":[],"href":"../../api/stable/napari.qt.threading.GeneratorWorkerSignals.html","text":"napari.qt.threading.GeneratorWorkerSignals"},"../../api/stable/napari.qt.threading.GeneratorWorker.html":{"level":3,"children":[],"href":"../../api/stable/napari.qt.threading.GeneratorWorker.html","text":"napari.qt.threading.GeneratorWorker"},"../../api/stable/napari.qt.threading.FunctionWorker.html":{"level":3,"children":[],"href":"../../api/stable/napari.qt.threading.FunctionWorker.html","text":"napari.qt.threading.FunctionWorker"},"../../api/stable/napari.components.html":{"level":2,"children":["../../api/stable/napari.components.Camera.html","../../api/stable/napari.components.Dims.html","../../api/stable/napari.components.LayerList.html","../../api/stable/napari.components.ViewerModel.html"],"href":"../../api/stable/napari.components.html","text":"napari.components"},"../../api/stable/napari.components.ViewerModel.html":{"level":3,"children":[],"href":"../../api/stable/napari.components.ViewerModel.html","text":"napari.components.ViewerModel"},"../../api/stable/napari.components.LayerList.html":{"level":3,"children":[],"href":"../../api/stable/napari.components.LayerList.html","text":"napari.components.LayerList"},"../../api/stable/napari.components.Dims.html":{"level":3,"children":[],"href":"../../api/stable/napari.components.Dims.html","text":"napari.components.Dims"},"../../api/stable/napari.components.Camera.html":{"level":3,"children":[],"href":"../../api/stable/napari.components.Camera.html","text":"napari.components.Camera"},"../../api/stable/napari.plugins.html":{"level":2,"children":["../../api/stable/napari.plugins.NapariPluginManager.html"],"href":"../../api/stable/napari.plugins.html","text":"napari.plugins"},"../../api/stable/napari.plugins.NapariPluginManager.html":{"level":3,"children":[],"href":"../../api/stable/napari.plugins.NapariPluginManager.html","text":"napari.plugins.NapariPluginManager"},"../../api/stable/napari.utils.html":{"level":2,"children":["../../api/stable/napari.utils.Colormap.html","../../api/stable/napari.utils.nbscreenshot.html"],"href":"../../api/stable/napari.utils.html","text":"napari.utils"},"../../api/stable/napari.utils.nbscreenshot.html":{"level":3,"children":[],"href":"../../api/stable/napari.utils.nbscreenshot.html","text":"napari.utils.nbscreenshot"},"../../api/stable/napari.utils.Colormap.html":{"level":3,"children":[],"href":"../../api/stable/napari.utils.Colormap.html","text":"napari.utils.Colormap"},"../../api/stable/napari.types.html":{"level":2,"children":["../../api/stable/napari.types.ArrayBase.html","../../api/stable/napari.types.Path.html","../../api/stable/napari.types.SampleDict.html","../../api/stable/napari.types.TracebackType.html","../../api/stable/napari.types.TypedDict.html"],"href":"../../api/stable/napari.types.html","text":"napari.types"},"../../api/stable/napari.types.TypedDict.html":{"level":3,"children":[],"href":"../../api/stable/napari.types.TypedDict.html","text":"napari.types.TypedDict"},"../../api/stable/napari.types.TracebackType.html":{"level":3,"children":[],"href":"../../api/stable/napari.types.TracebackType.html","text":"napari.types.TracebackType"},"../../api/stable/napari.types.SampleDict.html":{"level":3,"children":[],"href":"../../api/stable/napari.types.SampleDict.html","text":"napari.types.SampleDict"},"../../api/stable/napari.types.Path.html":{"level":3,"children":[],"href":"../../api/stable/napari.types.Path.html","text":"napari.types.Path"},"../../api/stable/napari.types.ArrayBase.html":{"level":3,"children":[],"href":"../../api/stable/napari.types.ArrayBase.html","text":"napari.types.ArrayBase"},"../../api/stable/napari.view_layers.html":{"level":2,"children":["../../api/stable/napari.view_layers.Viewer.html"],"href":"../../api/stable/napari.view_layers.html","text":"napari.view_layers"},"../../api/stable/napari.view_layers.Viewer.html":{"level":3,"children":[],"href":"../../api/stable/napari.view_layers.Viewer.html","text":"napari.view_layers.Viewer"},"../../api/stable/napari.layers.html":{"level":2,"children":["../../api/stable/napari.layers.Image.html","../../api/stable/napari.layers.Labels.html","../../api/stable/napari.layers.Layer.html","../../api/stable/napari.layers.Points.html","../../api/stable/napari.layers.Shapes.html","../../api/stable/napari.layers.Surface.html","../../api/stable/napari.layers.Tracks.html","../../api/stable/napari.layers.Vectors.html"],"href":"../../api/stable/napari.layers.html","text":"napari.layers"},"../../api/stable/napari.layers.Vectors.html":{"level":3,"children":[],"href":"../../api/stable/napari.layers.Vectors.html","text":"napari.layers.Vectors"},"../../api/stable/napari.layers.Tracks.html":{"level":3,"children":[],"href":"../../api/stable/napari.layers.Tracks.html","text":"napari.layers.Tracks"},"../../api/stable/napari.layers.Surface.html":{"level":3,"children":[],"href":"../../api/stable/napari.layers.Surface.html","text":"napari.layers.Surface"},"../../api/stable/napari.layers.Shapes.html":{"level":3,"children":[],"href":"../../api/stable/napari.layers.Shapes.html","text":"napari.layers.Shapes"},"../../api/stable/napari.layers.Points.html":{"level":3,"children":[],"href":"../../api/stable/napari.layers.Points.html","text":"napari.layers.Points"},"../../api/stable/napari.layers.Layer.html":{"level":3,"children":[],"href":"../../api/stable/napari.layers.Layer.html","text":"napari.layers.Layer"},"../../api/stable/napari.layers.Labels.html":{"level":3,"children":[],"href":"../../api/stable/napari.layers.Labels.html","text":"napari.layers.Labels"},"../../api/stable/napari.layers.Image.html":{"level":3,"children":[],"href":"../../api/stable/napari.layers.Image.html","text":"napari.layers.Image"},"../../release/index.html":{"level":1,"children":["../../release/release_0_4_10.html","../../release/release_0_4_9.html","../../release/release_0_4_8.html","../../release/release_0_4_7.html","../../release/release_0_4_6.html","../../release/release_0_4_5.html","../../release/release_0_4_4.html","../../release/release_0_4_3.html","../../release/release_0_4_2.html","../../release/release_0_4_1.html","../../release/release_0_4_0.html","../../release/release_0_3_8.html","../../release/release_0_3_7.html","../../release/release_0_3_6.html","../../release/release_0_3_5.html","../../release/release_0_3_4.html","../../release/release_0_3_3.html","../../release/release_0_3_2.html","../../release/release_0_3_1.html","../../release/release_0_3_0.html","../../release/release_0_2_12.html","../../release/release_0_2_11.html","../../release/release_0_2_10.html","../../release/release_0_2_9.html","../../release/release_0_2_8.html","../../release/release_0_2_7.html","../../release/release_0_2_6.html","../../release/release_0_2_5.html","../../release/release_0_2_4.html","../../release/release_0_2_3.html","../../release/release_0_2_1.html","../../release/release_0_2_0.html","../../release/release_0_1_5.html","../../release/release_0_1_3.html","../../release/release_0_1_0.html","../../release/release_0_4_11.html"],"href":"../../release/index.html","text":"Release notes"},"../../release/release_0_4_11.html":{"level":2,"children":[],"href":"../../release/release_0_4_11.html","text":"napari 0.4.11"},"../../release/release_0_1_0.html":{"level":2,"children":[],"href":"../../release/release_0_1_0.html","text":"napari 0.1.0"},"../../release/release_0_1_3.html":{"level":2,"children":[],"href":"../../release/release_0_1_3.html","text":"napari 0.1.3"},"../../release/release_0_1_5.html":{"level":2,"children":[],"href":"../../release/release_0_1_5.html","text":"napari 0.1.5"},"../../release/release_0_2_0.html":{"level":2,"children":[],"href":"../../release/release_0_2_0.html","text":"napari 0.2.0"},"../../release/release_0_2_1.html":{"level":2,"children":[],"href":"../../release/release_0_2_1.html","text":"napari 0.2.1"},"../../release/release_0_2_3.html":{"level":2,"children":[],"href":"../../release/release_0_2_3.html","text":"napari 0.2.3"},"../../release/release_0_2_4.html":{"level":2,"children":[],"href":"../../release/release_0_2_4.html","text":"napari 0.2.4"},"../../release/release_0_2_5.html":{"level":2,"children":[],"href":"../../release/release_0_2_5.html","text":"napari 0.2.5"},"../../release/release_0_2_6.html":{"level":2,"children":[],"href":"../../release/release_0_2_6.html","text":"napari 0.2.6"},"../../release/release_0_2_7.html":{"level":2,"children":[],"href":"../../release/release_0_2_7.html","text":"napari 0.2.7"},"../../release/release_0_2_8.html":{"level":2,"children":[],"href":"../../release/release_0_2_8.html","text":"napari 0.2.8"},"../../release/release_0_2_9.html":{"level":2,"children":[],"href":"../../release/release_0_2_9.html","text":"napari 0.2.9"},"../../release/release_0_2_10.html":{"level":2,"children":[],"href":"../../release/release_0_2_10.html","text":"napari 0.2.10"},"../../release/release_0_2_11.html":{"level":2,"children":[],"href":"../../release/release_0_2_11.html","text":"napari 0.2.11"},"../../release/release_0_2_12.html":{"level":2,"children":[],"href":"../../release/release_0_2_12.html","text":"napari 0.2.12"},"../../release/release_0_3_0.html":{"level":2,"children":[],"href":"../../release/release_0_3_0.html","text":"napari 0.3.0"},"../../release/release_0_3_1.html":{"level":2,"children":[],"href":"../../release/release_0_3_1.html","text":"napari 0.3.1"},"../../release/release_0_3_2.html":{"level":2,"children":[],"href":"../../release/release_0_3_2.html","text":"napari 0.3.2"},"../../release/release_0_3_3.html":{"level":2,"children":[],"href":"../../release/release_0_3_3.html","text":"napari 0.3.3"},"../../release/release_0_3_4.html":{"level":2,"children":[],"href":"../../release/release_0_3_4.html","text":"napari 0.3.4"},"../../release/release_0_3_5.html":{"level":2,"children":[],"href":"../../release/release_0_3_5.html","text":"napari 0.3.5"},"../../release/release_0_3_6.html":{"level":2,"children":[],"href":"../../release/release_0_3_6.html","text":"napari 0.3.6"},"../../release/release_0_3_7.html":{"level":2,"children":[],"href":"../../release/release_0_3_7.html","text":"napari 0.3.7"},"../../release/release_0_3_8.html":{"level":2,"children":[],"href":"../../release/release_0_3_8.html","text":"napari 0.3.8"},"../../release/release_0_4_0.html":{"level":2,"children":[],"href":"../../release/release_0_4_0.html","text":"napari 0.4.0"},"../../release/release_0_4_1.html":{"level":2,"children":[],"href":"../../release/release_0_4_1.html","text":"napari 0.4.1"},"../../release/release_0_4_2.html":{"level":2,"children":[],"href":"../../release/release_0_4_2.html","text":"napari 0.4.2"},"../../release/release_0_4_3.html":{"level":2,"children":[],"href":"../../release/release_0_4_3.html","text":"napari 0.4.3"},"../../release/release_0_4_4.html":{"level":2,"children":[],"href":"../../release/release_0_4_4.html","text":"napari 0.4.4"},"../../release/release_0_4_5.html":{"level":2,"children":[],"href":"../../release/release_0_4_5.html","text":"napari 0.4.5"},"../../release/release_0_4_6.html":{"level":2,"children":[],"href":"../../release/release_0_4_6.html","text":"napari 0.4.6"},"../../release/release_0_4_7.html":{"level":2,"children":[],"href":"../../release/release_0_4_7.html","text":"napari 0.4.7"},"../../release/release_0_4_8.html":{"level":2,"children":[],"href":"../../release/release_0_4_8.html","text":"napari 0.4.8"},"../../release/release_0_4_9.html":{"level":2,"children":[],"href":"../../release/release_0_4_9.html","text":"napari 0.4.9"},"../../release/release_0_4_10.html":{"level":2,"children":[],"href":"../../release/release_0_4_10.html","text":"napari 0.4.10"},"../../plugins/stable/index.html":{"level":1,"children":["../../plugins/stable/for_napari_developers.html","../../plugins/stable/for_plugin_developers.html","../../plugins/stable/hook_specifications.html","../../plugins/stable/find-and-install-plugin.html"],"href":"../../plugins/stable/index.html","text":"Plugins"},"../../plugins/stable/find-and-install-plugin.html":{"level":2,"children":[],"href":"../../plugins/stable/find-and-install-plugin.html","text":"Finding and installing a napari plugin"},"../../plugins/stable/hook_specifications.html":{"level":2,"children":[],"href":"../../plugins/stable/hook_specifications.html","text":"napari hook specification reference"},"../../plugins/stable/for_plugin_developers.html":{"level":2,"children":[],"href":"../../plugins/stable/for_plugin_developers.html","text":"creating a napari plugin"},"../../plugins/stable/for_napari_developers.html":{"level":2,"children":[],"href":"../../plugins/stable/for_napari_developers.html","text":"napari plugin architecture"},"../index.html":{"level":1,"children":["../fundamentals/index.html","index.html"],"href":"../index.html","text":"Tutorials"},"index.html":{"level":2,"children":["annotate_segmentation.html","annotate_points.html","#","napari_imageJ.html","cell_tracking.html"],"href":"index.html","text":"Applications"},"cell_tracking.html":{"level":3,"children":[],"href":"cell_tracking.html","text":"single cell tracking with napari"},"napari_imageJ.html":{"level":3,"children":[],"href":"napari_imageJ.html","text":"Napari + ImageJ How-to-Guide"},"#":{"level":3,"children":[],"href":"#","text":"using dask and napari to process & view large datasets"},"annotate_points.html":{"level":3,"children":[],"href":"annotate_points.html","text":"annotating videos with napari"},"annotate_segmentation.html":{"level":3,"children":[],"href":"annotate_segmentation.html","text":"annotating segmentation with text and bounding boxes"},"../fundamentals/index.html":{"level":2,"children":["../fundamentals/installation.html","../fundamentals/getting_started.html","../fundamentals/viewer.html","../fundamentals/image.html","../fundamentals/labels.html","../fundamentals/points.html","../fundamentals/shapes.html","../fundamentals/surface.html","../fundamentals/tracks.html","../fundamentals/vectors.html"],"href":"../fundamentals/index.html","text":"Fundamentals"},"../fundamentals/vectors.html":{"level":3,"children":[],"href":"../fundamentals/vectors.html","text":"vectors layer tutorial"},"../fundamentals/tracks.html":{"level":3,"children":[],"href":"../fundamentals/tracks.html","text":"tracks layer tutorial"},"../fundamentals/surface.html":{"level":3,"children":[],"href":"../fundamentals/surface.html","text":"surface layer tutorial"},"../fundamentals/shapes.html":{"level":3,"children":[],"href":"../fundamentals/shapes.html","text":"shapes layer tutorial"},"../fundamentals/points.html":{"level":3,"children":[],"href":"../fundamentals/points.html","text":"points layer tutorial"},"../fundamentals/labels.html":{"level":3,"children":[],"href":"../fundamentals/labels.html","text":"labels layer tutorial"},"../fundamentals/image.html":{"level":3,"children":[],"href":"../fundamentals/image.html","text":"image layer tutorial"},"../fundamentals/viewer.html":{"level":3,"children":[],"href":"../fundamentals/viewer.html","text":"napari viewer tutorial"},"../fundamentals/getting_started.html":{"level":3,"children":[],"href":"../fundamentals/getting_started.html","text":"getting started with napari"},"../fundamentals/installation.html":{"level":3,"children":[],"href":"../fundamentals/installation.html","text":"napari installation tutorial"},"../../community/index.html":{"level":1,"children":["../../community/mission_and_values.html","../../community/team.html","../../community/code_of_conduct.html","../../community/code_of_conduct_reporting.html","../../community/governance.html"],"href":"../../community/index.html","text":"Community"},"../../community/governance.html":{"level":2,"children":[],"href":"../../community/governance.html","text":"Governance Model"},"../../community/code_of_conduct_reporting.html":{"level":2,"children":[],"href":"../../community/code_of_conduct_reporting.html","text":"Handling Code of Conduct Reports"},"../../community/code_of_conduct.html":{"level":2,"children":[],"href":"../../community/code_of_conduct.html","text":"Code of Conduct"},"../../community/team.html":{"level":2,"children":[],"href":"../../community/team.html","text":"About the Project and Team"},"../../community/mission_and_values.html":{"level":2,"children":[],"href":"../../community/mission_and_values.html","text":"Mission and Values"}},"rootGlobalHeaders":["../../community/index.html","../index.html","../../plugins/stable/index.html","../../release/index.html","../../api/stable/index.html","../../roadmaps/index.html","../../guides/stable/index.html","../../developers/index.html","https://github.com/napari/napari","https://napari-hub.org"],"pageTitle":"using dask and napari to process & view large datasets","pageBodyHtml":"\n        <div class=\"section\" id=\"using-dask-and-napari-to-process-view-large-datasets\">\n\n<p>Often in microscopy, multidimensional data is acquired and written to disk in many small files,\neach of which contain a subset of one or more dimensions from the complete dataset.\nFor example, in a 5-dimensional experiment\n(e.g. 3D z-stacks acquired for multiple channels at various moments over time),\neach file on disk might be a 3D TIFF stack from a single channel at a single timepoint.\nData may also be stored in some proprietary format.\nAs the size of the dataset grows,\nviewing arbitrary slices (in time, channel, z) of these datasets can become cumbersome.</p>\n<p>Chunked file formats exist (such as <a class=\"reference external\" href=\"https://support.hdfgroup.org/HDF5/\">hdf5</a> and <a class=\"reference external\" href=\"https://zarr.readthedocs.io/en/stable/\">zarr</a>) that store data in a way that makes it easier to retrieve arbitrary subsets of the dataset, but they require either data duplication, or “committing” to a new file standard.</p>\n<blockquote>\n<div><p><strong>Note</strong>: This tutorial is not meant to promote a folder of TIFFs as a “good way” to store large datasets on disk;\nbut it is undoubtedly a common scenario in microscopy.\nChunked formats such as <code class=\"docutils literal notranslate\"><span class=\"pre\">hdf5</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">zarr</span></code> are superior in many ways,\nbut they do require the user to either duplicate their data\nor go “all in” and delete the original data after conversion.\nAnd while <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code> can easily handle something like a <code class=\"docutils literal notranslate\"><span class=\"pre\">zarr</span></code> store,\nit can be a bit more limiting inasmuch as it requires programs that are capable of viewing it (i.e. you can’t necessarily just drag it into Fiji …)</p>\n</div></blockquote>\n<p>The first part of this tutorial demonstrates how to use <a class=\"reference external\" href=\"https://docs.dask.org/en/latest/\"><code class=\"docutils literal notranslate\"><span class=\"pre\">Dask</span></code></a>\nand <a class=\"reference external\" href=\"https://docs.dask.org/en/latest/delayed.html\"><code class=\"docutils literal notranslate\"><span class=\"pre\">dask.delayed</span></code></a>\n(or <a class=\"reference external\" href=\"https://github.com/dask/dask-image\"><code class=\"docutils literal notranslate\"><span class=\"pre\">dask_image</span></code></a>) to feed <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code> image data “<a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Lazy_evaluation\">lazily</a>”:\nthat is, the specific image file corresponding to the requested timepoint/channel\nis only read from disk at the moment it is required\n(based on the current position of the dimension sliders in <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code>).\nAdditionally, we will see that <em>any</em> function that takes a filepath\nand returns a <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy</span></code> array can be used to lazily read image data.\nThis can be useful if you have a proprietary format that is not immediately recognized by <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code>\n(but for which you have at least some way of reading into a <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy</span></code> array)</p>\n<p>In some cases, data must be further processed prior to viewing,\nsuch as a deskewing step for images acquired on a stage-scanning light sheet microscope.\nOr perhaps you’d like to apply some basic image corrections or ratiometry prior to viewing.\nThe second part of this tutorial demonstrates the use of the <a class=\"reference external\" href=\"https://docs.dask.org/en/latest/array-api.html#dask.array.map_blocks\"><code class=\"docutils literal notranslate\"><span class=\"pre\">dask.array.map_blocks</span></code></a> function\nto describe an arbitrary sequence of functions in a declarative manner\nthat will be performed <em>on demand</em> as you explore the data (i.e. move the sliders) in <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code>.</p>\n<div class=\"section\" id=\"using-dask-delayed-to-load-images\">\n<h2>using dask.delayed to load images</h2>\n<p>If you have a function that can take a filename and return a <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy</span></code> array,\nsuch as <code class=\"docutils literal notranslate\"><span class=\"pre\">skimage.io.imread</span></code>,\nyou can create a “lazy” version of that function by calling <code class=\"docutils literal notranslate\"><span class=\"pre\">dask.delayed</span></code> on the function itself.\nThis <em>new</em> function, when handed a filename,\nwill not actually read the file until explicitly asked with the <code class=\"docutils literal notranslate\"><span class=\"pre\">compute()</span></code> method:</p>\n<div class=\"highlight-python notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">skimage.io</span> <span class=\"kn\">import</span> <span class=\"n\">imread</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dask</span> <span class=\"kn\">import</span> <span class=\"n\">delayed</span>\n\n<span class=\"n\">lazy_imread</span> <span class=\"o\">=</span> <span class=\"n\">delayed</span><span class=\"p\">(</span><span class=\"n\">imread</span><span class=\"p\">)</span>\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">lazy_imread</span><span class=\"p\">(</span><span class=\"s1\">'/path/to/file.tif'</span><span class=\"p\">)</span>  <span class=\"c1\"># doesn't actually read the file</span>\n<span class=\"n\">array</span> <span class=\"o\">=</span> <span class=\"n\">reader</span><span class=\"o\">.</span><span class=\"n\">compute</span><span class=\"p\">()</span>  <span class=\"c1\"># *now* it reads.</span>\n</pre></div>\n</div>\n<p>(If you have an unusual image format,\nbut you <em>do</em> have a python function that returns a <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy</span></code> array,\nsimply substitute it for <code class=\"docutils literal notranslate\"><span class=\"pre\">skimage.io.imread</span></code> in the example above).</p>\n<p>We can create a <a class=\"reference external\" href=\"https://docs.dask.org/en/latest/array.html\">Dask array</a> of delayed file-readers\nfor <em>all</em> of the files in our multidimensional experiment using the <code class=\"docutils literal notranslate\"><span class=\"pre\">dask.array.from_delayed</span></code> function\nand a <a class=\"reference external\" href=\"https://docs.python.org/3/library/glob.html\"><code class=\"docutils literal notranslate\"><span class=\"pre\">glob</span></code></a> filename pattern\n(<em>this example assumes that all files are of the same <code class=\"docutils literal notranslate\"><span class=\"pre\">shape</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code>!</em>):</p>\n<div class=\"highlight-python notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">skimage.io</span> <span class=\"kn\">import</span> <span class=\"n\">imread</span>\n<span class=\"kn\">from</span> <span class=\"nn\">skimage.io.collection</span> <span class=\"kn\">import</span> <span class=\"n\">alphanumeric_key</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dask</span> <span class=\"kn\">import</span> <span class=\"n\">delayed</span>\n<span class=\"kn\">import</span> <span class=\"nn\">dask.array</span> <span class=\"k\">as</span> <span class=\"nn\">da</span>\n<span class=\"kn\">from</span> <span class=\"nn\">glob</span> <span class=\"kn\">import</span> <span class=\"n\">glob</span>\n\n<span class=\"n\">filenames</span> <span class=\"o\">=</span> <span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">glob</span><span class=\"p\">(</span><span class=\"s2\">\"/path/to/experiment/*.tif\"</span><span class=\"p\">),</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">alphanumeric_key</span><span class=\"p\">)</span>\n<span class=\"c1\"># read the first file to get the shape and dtype</span>\n<span class=\"c1\"># ASSUMES THAT ALL FILES SHARE THE SAME SHAPE/TYPE</span>\n<span class=\"n\">sample</span> <span class=\"o\">=</span> <span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"n\">filenames</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n\n<span class=\"n\">lazy_imread</span> <span class=\"o\">=</span> <span class=\"n\">delayed</span><span class=\"p\">(</span><span class=\"n\">imread</span><span class=\"p\">)</span>  <span class=\"c1\"># lazy reader</span>\n<span class=\"n\">lazy_arrays</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">lazy_imread</span><span class=\"p\">(</span><span class=\"n\">fn</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">fn</span> <span class=\"ow\">in</span> <span class=\"n\">filenames</span><span class=\"p\">]</span>\n<span class=\"n\">dask_arrays</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"n\">da</span><span class=\"o\">.</span><span class=\"n\">from_delayed</span><span class=\"p\">(</span><span class=\"n\">delayed_reader</span><span class=\"p\">,</span> <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"n\">sample</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">sample</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">delayed_reader</span> <span class=\"ow\">in</span> <span class=\"n\">lazy_arrays</span>\n<span class=\"p\">]</span>\n<span class=\"c1\"># Stack into one large dask.array</span>\n<span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"n\">da</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"p\">(</span><span class=\"n\">dask_arrays</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">shape</span>  <span class=\"c1\"># (nfiles, nz, ny, nx)</span>\n\n<span class=\"c1\"># in jupyter notebook the repr of a dask stack provides a useful visual:</span>\n<span class=\"n\">stack</span>\n</pre></div>\n</div>\n<p><img alt=\"image: dask array html representation\" src=\"../../_images/dask_repr.png\"></p>\n<p><em>No data has been read from disk yet!</em></p>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code> is capable of consuming Dask arrays,\nso you can simply call <code class=\"docutils literal notranslate\"><span class=\"pre\">napari.view_image</span></code> on this <code class=\"docutils literal notranslate\"><span class=\"pre\">stack</span></code> and behind the scenes,\nDask will take care of reading the data from disk\nand handing a <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy</span></code> array to <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code> each time a new timepoint or channel is requested.</p>\n<div class=\"highlight-python notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">napari</span>\n\n<span class=\"c1\"># specify contrast_limits and is_pyramid=False with big data</span>\n<span class=\"c1\"># to avoid unnecessary computations</span>\n<span class=\"n\">napari</span><span class=\"o\">.</span><span class=\"n\">view_image</span><span class=\"p\">(</span><span class=\"n\">stack</span><span class=\"p\">,</span> <span class=\"n\">contrast_limits</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">2000</span><span class=\"p\">],</span> <span class=\"n\">multiscale</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p><em>Note: providing the</em> <code class=\"docutils literal notranslate\"><span class=\"pre\">contrast_limits</span></code> <em>and</em> <code class=\"docutils literal notranslate\"><span class=\"pre\">multiscale</span></code> <em>arguments prevents</em> <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code> <em>from trying to calculate the data min/max, which can take an extremely long time with big data.\nSee <a class=\"reference external\" href=\"https://github.com/napari/napari/issues/736\">napari issue #736</a> for further discussion.</em></p>\n</div>\n<div class=\"section\" id=\"make-your-life-easier-with-dask-image\">\n<h2>make your life easier with <code class=\"docutils literal notranslate\"><span class=\"pre\">dask-image</span></code></h2>\n<p>This pattern for creating a <code class=\"docutils literal notranslate\"><span class=\"pre\">dask.array</span></code> from image data\nhas been previously described in an <a class=\"reference external\" href=\"https://blog.dask.org/2019/06/20/load-image-data\">excellent blog post</a> by John Kirkham.\nIt is a common-enough pattern that John created a useful library (<a class=\"reference external\" href=\"https://github.com/dask/dask-image\"><code class=\"docutils literal notranslate\"><span class=\"pre\">dask-image</span></code></a>)\nthat does all this for you,\nprovided your image format can be read by the <a class=\"reference external\" href=\"https://github.com/soft-matter/pims\"><code class=\"docutils literal notranslate\"><span class=\"pre\">pims</span></code></a> (Python Image Sequence) reader\n(if not, see note above about providing your own reader function with <code class=\"docutils literal notranslate\"><span class=\"pre\">dask.delayed</span></code>).</p>\n<p>Using <code class=\"docutils literal notranslate\"><span class=\"pre\">dask-image</span></code>, <em>all</em> of the above code can be simplified to 5 lines:</p>\n<div class=\"highlight-python notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">napari</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dask_image.imread</span> <span class=\"kn\">import</span> <span class=\"n\">imread</span>\n\n<span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s2\">\"/path/to/experiment/*.tif\"</span><span class=\"p\">)</span>\n<span class=\"n\">napari</span><span class=\"o\">.</span><span class=\"n\">view_image</span><span class=\"p\">(</span><span class=\"n\">stack</span><span class=\"p\">,</span> <span class=\"n\">contrast_limits</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">2000</span><span class=\"p\">],</span> <span class=\"n\">is_pyramid</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p><img alt=\"image: mCherry-H2B showing chromosome separation during mitosis. Collected on a lattice light sheet microscope\" src=\"../../_images/dask1.gif\"></p>\n<div class=\"section\" id=\"side-note-regarding-higher-dimensional-datasets\">\n<h3><strong>side note regarding higher-dimensional datasets</strong></h3>\n<p>In the above example, it would be quite common to have a 5+ dimensional dataset\n(e.g. different timepoints <em>and</em> channels represented among the 3D TIFF files in a folder).\nA standard approach to deal with that sort of thing in <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy</span></code> would be to <code class=\"docutils literal notranslate\"><span class=\"pre\">reshape</span></code> the array after instantiation.\nWith Dask, reshaping arrays can <em>sometimes</em> lead to unexpected read events if you’re not careful.</p>\n<p>For example:</p>\n<div class=\"highlight-python notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dask_image.imread</span> <span class=\"kn\">import</span> <span class=\"n\">imread</span>\n<span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s1\">'/path/to/experiment/*.tif'</span><span class=\"p\">)</span>\n<span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">shape</span>  <span class=\"c1\"># -&gt; something like (1200, 64, 256, 280)</span>\n<span class=\"n\">stack</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">compute</span><span class=\"p\">()</span>  <span class=\"c1\"># incurs a single file read</span>\n\n<span class=\"c1\"># if there were two channels in that folder you might try to do this:</span>\n<span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">600</span><span class=\"p\">,</span> <span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"mi\">256</span><span class=\"p\">,</span> <span class=\"mi\">280</span><span class=\"p\">)</span>\n<span class=\"c1\"># but now trying to read just the first timepoint in the first channel:</span>\n<span class=\"n\">stack</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">compute</span><span class=\"p\">()</span>  <span class=\"c1\"># incurs 600 read events!</span>\n</pre></div>\n</div>\n<p>We will update this post as best-practices emerge,\nbut one possible solution to this is to avoid reshaping\nDask arrays altogether, by constructing multiple Dask arrays using <code class=\"docutils literal notranslate\"><span class=\"pre\">dask-image</span></code>, and then using\n<code class=\"docutils literal notranslate\"><span class=\"pre\">da.stack</span></code> to combine them:</p>\n<div class=\"highlight-python notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dask_image.imread</span> <span class=\"kn\">import</span> <span class=\"n\">imread</span>\n<span class=\"kn\">import</span> <span class=\"nn\">dask.array</span> <span class=\"k\">as</span> <span class=\"nn\">da</span>\n\n<span class=\"c1\"># # instead of this</span>\n<span class=\"c1\"># stack = imread('/path/to/experiment/*.tif')</span>\n<span class=\"c1\"># stack = stack.reshape(2, 600, 64, 256, 280)</span>\n<span class=\"c1\"># stack[0, 0].compute()  # incurs 600 read events!</span>\n\n<span class=\"c1\"># do something like this:</span>\n<span class=\"n\">file_pattern</span> <span class=\"o\">=</span> <span class=\"s2\">\"/path/to/experiment/*ch</span><span class=\"si\">{}</span><span class=\"s2\">*.tif\"</span>\n<span class=\"n\">channels</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"n\">file_pattern</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">))</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">nchannels</span><span class=\"p\">)]</span>\n<span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"n\">da</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"p\">(</span><span class=\"n\">channels</span><span class=\"p\">)</span>\n<span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">shape</span>  <span class=\"c1\"># (2, 600, 64, 256, 280)</span>\n<span class=\"n\">stack</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">compute</span><span class=\"p\">()</span>  <span class=\"c1\"># incurs a single file read</span>\n\n</pre></div>\n</div>\n</div>\n</div>\n<div class=\"section\" id=\"processing-data-with-dask-array-map-blocks\">\n<h2>processing data with <code class=\"docutils literal notranslate\"><span class=\"pre\">dask.array.map_blocks</span></code></h2>\n<p>As previously mentioned,\nsometimes it is desirable to process data prior to viewing.\nWe’ll take as an example\na series of TIFF files acquired on a lattice-light-sheet microscope.\nA typical workflow might be to deskew, deconvolve, and perhaps crop\nor apply some channel registration prior to viewing.</p>\n<p>With <code class=\"docutils literal notranslate\"><span class=\"pre\">dask.array.map_blocks</span></code> we can apply any function that accepts a <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy</span></code> array\nand returns a modified array to all the images in our <code class=\"docutils literal notranslate\"><span class=\"pre\">dask.array</span></code>.\nIt will be evaluated lazily, when requested (in this case, by <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code>);\nwe do not have to wait for it to process the entire dataset.</p>\n<p>Here is an example of a script that will take a folder of raw tiff files,\nand lazily read, deskew, deconvolve, crop,\nand display them, <em>on demand</em> as you move the <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code> dimensions sliders around.</p>\n<div class=\"highlight-python notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">napari</span>\n<span class=\"kn\">import</span> <span class=\"nn\">pycudadecon</span>\n<span class=\"kn\">from</span> <span class=\"nn\">functools</span> <span class=\"kn\">import</span> <span class=\"n\">partial</span>\n<span class=\"kn\">from</span> <span class=\"nn\">skimage</span> <span class=\"kn\">import</span> <span class=\"n\">io</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dask_image.imread</span> <span class=\"kn\">import</span> <span class=\"n\">imread</span>\n\n<span class=\"c1\"># load stacks with dask_image, and psf with skimage</span>\n<span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s2\">\"/path/to/experiment/*.tif\"</span><span class=\"p\">)</span>\n<span class=\"n\">psf</span> <span class=\"o\">=</span> <span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s2\">\"/path/to/psf.tif\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># prepare some functions that accept a numpy array</span>\n<span class=\"c1\"># and return a processed array</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">last3dims</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">):</span>\n    <span class=\"c1\"># this is just a wrapper because the pycudadecon function</span>\n    <span class=\"c1\"># expects ndims==3 but our blocks will have ndim==4</span>\n    <span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])[</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>\n    <span class=\"k\">return</span> <span class=\"n\">func</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">crop</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">):</span>\n    <span class=\"c1\"># simple cropping function</span>\n    <span class=\"k\">return</span> <span class=\"n\">array</span><span class=\"p\">[:,</span> <span class=\"mi\">2</span><span class=\"p\">:,</span> <span class=\"mi\">10</span><span class=\"p\">:</span><span class=\"o\">-</span><span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"p\">:</span><span class=\"mi\">500</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># https://docs.python.org/3.8/library/functools.html#functools.partial</span>\n<span class=\"n\">deskew</span> <span class=\"o\">=</span> <span class=\"n\">last3dims</span><span class=\"p\">(</span><span class=\"n\">partial</span><span class=\"p\">(</span><span class=\"n\">pycudadecon</span><span class=\"o\">.</span><span class=\"n\">deskew_gpu</span><span class=\"p\">,</span> <span class=\"n\">angle</span><span class=\"o\">=</span><span class=\"mf\">31.5</span><span class=\"p\">))</span>\n<span class=\"n\">deconv</span> <span class=\"o\">=</span> <span class=\"n\">last3dims</span><span class=\"p\">(</span><span class=\"n\">partial</span><span class=\"p\">(</span><span class=\"n\">pycudadecon</span><span class=\"o\">.</span><span class=\"n\">decon</span><span class=\"p\">,</span> <span class=\"n\">psf</span><span class=\"o\">=</span><span class=\"n\">psf</span><span class=\"p\">,</span> <span class=\"n\">background</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">))</span>\n<span class=\"c1\"># note: this is done in two steps just as an example...</span>\n<span class=\"c1\"># in reality pycudadecon.decon also has a deskew argument</span>\n\n<span class=\"c1\"># map and chain those functions across all dask blocks</span>\n<span class=\"n\">deskewed</span> <span class=\"o\">=</span> <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">map_blocks</span><span class=\"p\">(</span><span class=\"n\">deskew</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s2\">\"uint16\"</span><span class=\"p\">)</span>\n<span class=\"n\">deconvolved</span> <span class=\"o\">=</span> <span class=\"n\">deskewed</span><span class=\"o\">.</span><span class=\"n\">map_blocks</span><span class=\"p\">(</span><span class=\"n\">deconv</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s2\">\"float32\"</span><span class=\"p\">)</span>\n<span class=\"n\">cropped</span> <span class=\"o\">=</span> <span class=\"n\">deconvolved</span><span class=\"o\">.</span><span class=\"n\">map_blocks</span><span class=\"p\">(</span><span class=\"n\">crop</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s2\">\"float32\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># put the resulting dask array into napari.</span>\n<span class=\"c1\"># (don't forget the contrast limits and is_pyramid==False !)</span>\n<span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">napari</span><span class=\"o\">.</span><span class=\"n\">view_image</span><span class=\"p\">(</span>\n    <span class=\"n\">cropped</span><span class=\"p\">,</span>\n    <span class=\"n\">contrast_limits</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">90</span><span class=\"p\">,</span> <span class=\"mi\">1500</span><span class=\"p\">],</span>\n    <span class=\"n\">is_pyramid</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span>\n    <span class=\"n\">ndisplay</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span>\n    <span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">),</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">napari</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<p>Of course, the GUI isn’t as responsive as it would be if you had processed the data up front\nand loaded the results into RAM and viewed them in <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code> (it’s doing a lot of work after all!),\nbut it’s surprisingly usable,\nand allows you to preview the result of a relatively complex processing pipeline <em>on-the-fly</em>,\nfor arbitrary timepoints/channels, while storing <em>only</em> the raw data on disk.</p>\n<p><img alt=\"image: same dataset, demonstrating on-the-fly read → deskew → deconvolve → crop\" src=\"../../_images/dask2.gif\"></p>\n<p>This workflow is very much patterned after <a class=\"reference external\" href=\"https://blog.dask.org/2019/08/09/image-itk\">another great post by John Kirkham, Matthew Rocklin, and Matthew McCormick</a>\nthat describes a similar image processing pipeline using <a class=\"reference external\" href=\"https://itk.org/\">ITK</a>.\n<code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code> simply sits at the end of this lazy processing chain,\nready to show you the result on demand!</p>\n</div>\n<div class=\"section\" id=\"further-reading\">\n<h2>Further Reading</h2>\n<p><a class=\"reference external\" href=\"https://docs.dask.org/en/latest/delayed.html\">Documentation on dask.delayed</a></p>\n<p><a class=\"reference external\" href=\"https://blog.dask.org/2019/06/20/load-image-data\">Dask working notes on dask-image</a></p>\n<p><a class=\"reference external\" href=\"https://blog.dask.org/2019/08/09/image-itk\">Dask working notes on image processing with <code class=\"docutils literal notranslate\"><span class=\"pre\">dask.array.map_blocks</span></code></a></p>\n</div>\n</div>\n\n    <script type=\"text/x-thebe-config\">\n    {\n        requestKernel: true,\n        binderOptions: {\n            repo: \"binder-examples/jupyter-stacks-datascience\",\n            ref: \"master\",\n        },\n        codeMirrorConfig: {\n            theme: \"abcdef\",\n            mode: \"python\"\n        },\n        kernelOptions: {\n            kernelName: \"python3\",\n            path: \"./tutorials/applications\"\n        },\n        predefinedOutput: true\n    }\n    </script>\n    <script>kernelName = 'python3'</script>\n      ","pageHeaders":[{"id":"using-dask-delayed-to-load-images","text":"using dask.delayed to load images"},{"id":"make-your-life-easier-with-dask-image","text":"make your life easier with dask-image"},{"id":"processing-data-with-dask-array-map-blocks","text":"processing data with dask.array.map_blocks"},{"id":"further-reading","text":"Further Reading"}]}},"__N_SSG":true}